[练习4.1](#)

>表达式5+10\*20/2的求值结果是多少？

    105

[练习4.2](#)

>根据4.12节中的表，在下述表达式的合理位置添加括号，使得添加括号后运算对象的组合顺序与添加括号前一致。  
(a) \*vec.begin()  
(b) \*vec.begin() + 1

    (a) \*(vec.begin())
    (b) (\*(vec.begin())) + 1

[练习4.3](#)

>C++语言没有明确规定大多数二元运算符的求值顺序，给编译器优化留下了余地。这种策略实际上是在代码生成效率和程序潜在缺陷之间进行了权衡，你认为这可以接受吗？请说出你的理由。

    可以接受，通过一定的方法可以强制让表达式的组合关系符合程序逻辑的要求。这种策略既提高了代码生成效率，同时也不会使得程序潜在缺陷不可避免

[练习4.4](#)

>在下面的表达式中添加括号，说明其求值的过程及最终结果。编写程序编译该（不加括号的）表达式并输出其结果验证之前的推断。

```cpp
12 / 3 * 4 + 5 * 15 + 24 % 4 / 2
```

```cpp
(((12 / 3) * 4) + (5 * 15)) + ((24 % 4) / 2)
```

[练习4.5](#)

>写出下列表达式的求值结果。  
(a) -30 * 3 + 21 / 5  
(b) -30 + 3 * 21 / 5  
(c) 30 / 3 * 21 % 5  
(d) -30 / 3 * 21 % 4

    (a) -86
    (b) -18
    (c) 0
    (d) -2

[练习4.6](#)

>写出一条表达式用于确定一个整数时奇数还是偶数。

```cpp
n % 2 != 0 ? true : false //true代表奇数，false代表偶数
```

[练习4.7](#)

>溢出是何含义？写出三条将导致溢出的表达式。

溢出表示计算的结果超出类型所能表示的范围所产生的异常情况

```cpp
//1.
short short_value = 32767;
short_value ++;

//2.
short short_value1 = 32760;
short short_value2 = 10;
short_value = short_value1 + short_value2;
```

//3.
unsigned short ushort_value3 = 17000;
ushort_value3 \*= 2;
